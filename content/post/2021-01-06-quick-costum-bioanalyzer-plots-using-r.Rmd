---
title: Quick costum bioanalyzer plots using R
author: Jorik Bot
date: '2021-01-06'
slug: quick-costum-bioanalyzer-plots-using-r
categories:
  - r
tags:
  - r
  - Tidyverse
subtitle: ''
summary: ''
authors: []
lastmod: '2021-01-06T20:27:16+01:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Intro

In this short post I will show how to quickly get bioanalyzer trace data into R and ready for plotting. 
On the way we will make use of the tidyverse packages.

```{r, message=FALSE}
library(tidyverse)
```

You can get the raw data out of the bioanalyzer by going file>export. Somewhat depending on the options you select next, it will spit out many different files:

```{r}
list.files(path = "./20210106data")
```

Annoyingly, the raw data for each well of the bioanalyzer chip is found in a separate csv file. Manually pasting these together in excel is too much clicking, and more importantly error prone. Depending on your location, excel may see the comma as the thousand separator, which makes converting the csv file into excel columns with Data > Text to Columns go wrong for some rows. Importing the csv files into r will not run into this problem. 

I generally start out by creating an r project in the folder containing the bioanalyzer data. Among other things, this avoids having to set the working directory. 
The next step is to separate the csv files containing the raw data from the rest. Luckily, they all always end in "Sample" + the well number + ".csv" (at least for RNA nano and pico chips). We can use this pattern to isolate them, by creating a regular expression and giving this pattern to `list.files()`. We are not interested in what comes before Sample, so we can preface Sample with the * symbol. This means zero or more of anything can occur. Sample is always followed by one or more digits. We tell the function to look for a digit using \\d and use + to allow for one or more them. Finally, all these files should end in .csv. The \$ sign signifies that the string should end there. We have now arrived at the regular expression "*Sample\\d+.csv$"

```{r}
# Ignore the path = , this is only here because of how the website is structured. 
# If you have made an r project inside the folder containing the bioanalyzer data you won't need it. 

samples <- list.files(path = "./20210106data", pattern = "*Sample\\d+.csv$")
samples
```

It worked!

Let's look at what happens when we import one of these files. 

```{r}
# Again, the path = , and paste0 shenanigans is only needed for the website. 
# In a normal situation just read_csv(samples[1]) would be enough.

path <- "./20210106data/"
sample1 <- read_csv(paste0(path, samples[1]))
sample1
```

The first few rows are metadata we are not really interested in. In fact, we can skip the first 17 rows. 

```{r}
sample1 <- read_csv(paste0(path, samples[1]),
                    skip = 17)
```

We get 2 parsing failures. That is because, all the way at the bottom of the file, some text ("alignment on") appears where only numbers are expected, which results in NA values in the final row of our table. 

```{r}
sample1[1055:1061,]
```

To prevent this we can tell `read_csv` to not read this far into the file. 

```{r}
sample1 <- read_csv(paste0(path, samples[1]),
                    skip = 17,
                    n_max = 1060)
```

No failures this time!

Now we can use a for loop to import all the data files and merge them into one big table. We will use `mutate` to make a new column that contains the well number each measurement originates from. `str_extract` is used to extract this information from the file name. 

```{r, message=FALSE}
all_data <- tibble()

for(i in samples){
  data <- read_csv(paste0(path, i), 
                   skip = 17, 
                   n_max = 1060)
  data <- mutate(data, sample_nr = str_extract(i, pattern = "Sample\\d+"))
  all_data <- rbind(all_data, data)
}
head(all_data)
```

It would be even more convenient if the sample_nr column only contained, well ... , numbers. 
Again `str_extract` can help use remove all the unwanted symbols. Even though we are only left we numbers, we still need to convert it to a numeric, because a string will stay a string until told otherwise. 

```{r}
all_data <- all_data %>%
  mutate(sample_nr = as.numeric(str_extract(sample_nr, pattern = "\\d+$")))
head(all_data)
```

Now it is also easy to add additional information about each sample. You could simply prepare a table in excel that contains at least a sample_nr column, and any number of additional columns with extra information. 

```{r, message=FALSE}
exp_design <- read_delim("20210106_exp_design.csv", delim = ";")
head(exp_design)
```

Finally we can join these two tables together based on the sample_nr column. 

```{r}
all_data <- all_data %>%
  left_join(exp_design, by = "sample_nr")
head(all_data)
```

At this point you could save the final table if you want to make plots in other software.

```{r, eval=FALSE}
write_csv(all_data, "bioanalyzer_data.csv")
```

Or you can make plots in r. 

```{r}
library(ggpubr)
library(ggsci)

all_data %>%
  ggplot(aes(x = Time, y = Value, color = as.character(sample_nr)))+
    geom_line()+
    facet_grid(cols = vars(treatment))+
    scale_x_continuous(breaks = c(20, 40, 60))+
    scale_color_jco(name = "Chip well")+
    theme_pubr()+
    labs(x = "Time in seconds",
         y = "Fluorescence (a.u.)")
```

